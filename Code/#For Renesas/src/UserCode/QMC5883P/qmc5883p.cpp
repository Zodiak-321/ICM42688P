/**
 * @file qmc5883p.cpp
 * @brief QMC5883P Magnetometer Sensor Driver Implementation
 * 
 * This file contains the implementation of the QMC5883P class methods
 * for interfacing with the QMC5883P 3-axis magnetometer sensor.
 * 
 * @author WilliTourt willitourt@foxmail.com
 * @version 1.0
 * @date 2025.11.28
 * 
 * @note Comments are mostly generated by AI
 * 
 * @CHANGELOG:
 * - (See qmc5883p.h for changes)
 * 
 */

#include "qmc5883p.h"
#include "r_iic_master.h"
#include "cpp_main.h"

extern "C" {
#include "iic.h"
    #include "stdio.h"
}

volatile bool g_IIC_transfer_complete = false;
volatile bool g_IIC_receiver_complete = false;

void i2c_callback(i2c_master_callback_args_t * p_args)
{
    if(p_args->event == I2C_MASTER_EVENT_TX_COMPLETE)
    {
        g_IIC_transfer_complete = true;
    }
    else if(p_args->event == I2C_MASTER_EVENT_RX_COMPLETE)
    {
        g_IIC_receiver_complete = true;
    }

}


/**
 * @brief Construct a new QMC5883P object
 * 
 * @param hi2c Pointer to I2C handle
 * @param mode Operation mode
 * @param speed Output data rate
 * @param range Measurement range
 */
QMC5883P::QMC5883P(QMC5883P_Mode mode, QMC5883P_Spd speed, QMC5883P_Rng range) :
    _mode(mode),
    _speed(speed),
    _range(range),
    _mag_x(0.0f),
    _mag_y(0.0f),
    _mag_z(0.0f) {
        
    switch (_range) {
        case QMC5883P_Rng::RNG_2G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_2G;
            break;
        case QMC5883P_Rng::RNG_8G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_8G;
            break;
        case QMC5883P_Rng::RNG_12G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_12G;
            break;
        case QMC5883P_Rng::RNG_30G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_30G;
            break;
    }
    
    _offset_x = MAG_X_OFFSET;
    _offset_y = MAG_Y_OFFSET;
    _offset_z = MAG_Z_OFFSET;
    _scale_x = MAG_X_SCALE;
    _scale_y = MAG_Y_SCALE;
    _scale_z = MAG_Z_SCALE;
}

/**
 * @brief Destroy the QMC5883P object
 */
QMC5883P::~QMC5883P() {}

/**
 * @brief Send data to the sensor via I2C
 * 
 * @param reg Register address
 * @param data Pointer to data buffer
 * @param len Length of data
 * @return HAL_StatusTypeDef Status of I2C operation
 */
bool QMC5883P::_i2cSend(uint8_t reg, uint8_t *data, uint8_t len) {
    // return HAL_I2C_Mem_Write(_hi2c, QMC5883P_ADDR << 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, QMC5883P_READ_TIMEOUT_MS);
    
    uint8_t send_buffer[7] = {0};

    send_buffer[0] = reg;
    for(int i = 0; i < len; i++)
        send_buffer[i + 1] = *(data + i);
    
    #if 0
    
    IIC_Start_Soft(0);
    IIC_SendByte_Soft(0, QMC5883P_ADDR << 1 | 0x00);
    if(IIC_RcvACK_Soft(0) != 0) return false;
    for(int i = 0; i < len + 1; i++)
    {
        IIC_SendByte_Soft(0, send_buffer[i]);
        if(IIC_RcvACK_Soft(0) != 0) return false;
    }
    IIC_Stop_Soft(0);
    #endif
    
    fsp_err_t err;
    
    err = R_IIC_MASTER_Write(g_i2c_master1.p_ctrl, send_buffer, len + 1, false);
    while(g_IIC_transfer_complete == false);
    g_IIC_transfer_complete = false;
    
    if(err != FSP_SUCCESS) return false;
    
    
    return true;
}

/**
 * @brief Receive data from the sensor via I2C
 * 
 * @param reg Register address
 * @param data Pointer to data buffer
 * @param len Length of data
 * @return HAL_StatusTypeDef Status of I2C operation
 */
bool QMC5883P::_i2cRecv(uint8_t reg, uint8_t *data, uint8_t len) {
    // return HAL_I2C_Mem_Read(_hi2c, QMC5883P_ADDR << 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, QMC5883P_READ_TIMEOUT_MS);

    #if 0
    IIC_Start_Soft(0);
    IIC_SendByte_Soft(0, QMC5883P_ADDR << 1 | 0x00);
    if(IIC_RcvACK_Soft(0) != 0) return false;
    IIC_SendByte_Soft(0, reg);
    if(IIC_RcvACK_Soft(0) != 0) return false;
    
    IIC_SendByte_Soft(0, QMC5883P_ADDR << 1 | 0x01);
    if(IIC_RcvACK_Soft(0) != 0) return false;
    IIC_Start_Soft(0);

    if(len == 1)
    {
        *data = IIC_ReadByte_Soft(0);
        IIC_SendACK_Soft(0, 1);         
    }
    else
    {
        for(int i = 0; i < len - 1; i++)
        {
            *(data + i) = IIC_ReadByte_Soft(0);
            IIC_SendACK_Soft(0, 0);
        }
        *(data + len - 1) = IIC_ReadByte_Soft(0);
        IIC_SendACK_Soft(0, 1);    
    }

    IIC_Stop_Soft(0);
    #endif
    
    fsp_err_t err;
    
    err = R_IIC_MASTER_Write(g_i2c_master1.p_ctrl, &reg, 1, true);
    while(g_IIC_transfer_complete == false);
    g_IIC_transfer_complete = false;
    if(err != FSP_SUCCESS) return false;
    
    err = R_IIC_MASTER_Read(g_i2c_master1.p_ctrl, data, len, false);
    while(g_IIC_receiver_complete == false);
    g_IIC_receiver_complete = false;
    if(err != FSP_SUCCESS) return false;

    return true;
}

/**
 * @brief Check if new data is available
 * 
 * @return true Data is ready
 * @return false Data is not ready
 */
bool QMC5883P::_isDataRdy() {
    uint8_t isReady = 0;

    if (_i2cRecv(QMC5883P_REG_STATUS, &isReady, 1) != true) {
        return false;
    }
    return (isReady & QMC5883P_STATUS_DRDY);
}

/**
 * @brief Initialize the QMC5883P sensor
 * 
 * This function performs the following steps:
 * 1. Resets the sensor
 * 2. Verifies the chip ID
 * 3. Configures the measurement range
 * 4. Sets the operation mode and data rate
 * 
 * @return QMC5883P_Status Status of initialization
 */
QMC5883P::QMC5883P_Status QMC5883P::begin() {
    uint8_t data;
    
    #if 0
    IIC_Init_Soft(QMC5883P_SCL, QMC5883P_SDA, 10, 0);
    #endif

    Delay(20);
    // Reset the sensor
    data = QMC5883P_CONTROL_2_SOFT_RESET;
    if (_i2cSend(QMC5883P_REG_CONTROL_2, &data, 1) != true) {
        return QMC5883P_Status::ERROR;
    }

    Delay(20);

    data = 0x00;
    if (_i2cSend(QMC5883P_REG_CONTROL_2, &data, 1) != true) {
        return QMC5883P_Status::ERROR;
    }

    Delay(20);

    if (_i2cRecv(QMC5883P_REG_CHIP_ID, &data, 1) != true) {
        return QMC5883P_Status::ERROR;        
    }
//    R_SCI_UART_Write(g_uart1.p_ctrl, &data, 1);
    if (data != QMC5883P_CHIP_ID) {
        return QMC5883P_Status::ERROR_ID;        
    }

    data = static_cast<uint8_t>(_range);
    if (_i2cSend(QMC5883P_REG_CONTROL_2, &data, 1) != true) {
        return QMC5883P_Status::ERROR;
    }

    // Configure the sensor
    data = static_cast<uint8_t>(_mode) | static_cast<uint8_t>(_speed) |
           QMC5883P_CONTROL_1_OSR1_2 | QMC5883P_CONTROL_1_OSR2_2;
    if (_i2cSend(QMC5883P_REG_CONTROL_1, &data, 1) != true) {
        return QMC5883P_Status::ERROR;        
    }

    return QMC5883P_Status::OK;
}

/**
 * @brief Read new data from the sensor
 * 
 * This function waits for data to be ready, reads the raw magnetic
 * field data from the sensor, applies calibration offsets and scaling,
 * and stores the calibrated values.
 * 
 * @return QMC5883P_Status Status of data reading
 */
QMC5883P::QMC5883P_Status QMC5883P::update() {
    uint8_t rawData[6];

    uint32_t start = getTick();

    while (!_isDataRdy()) {
        if (getTick() - start > QMC5883P_READ_TIMEOUT_MS) {
            return QMC5883P_Status::ERROR;
        }
        Delay(1);
    }

    if (_i2cRecv(QMC5883P_REG_XOUT_L, rawData, 6) != true) {
        return QMC5883P_Status::ERROR;
    }

    int16_t raw_x = (int16_t)(rawData[1] << 8 | rawData[0]);
    int16_t raw_y = (int16_t)(rawData[3] << 8 | rawData[2]);
    int16_t raw_z = (int16_t)(rawData[5] << 8 | rawData[4]);

    // Apply calibration offsets and scaling
    _mag_x = ((float)raw_x / (float)_sensitivity - _offset_x) * _scale_x;
    _mag_y = ((float)raw_y / (float)_sensitivity - _offset_y) * _scale_y;
    _mag_z = ((float)raw_z / (float)_sensitivity - _offset_z) * _scale_z;

    return QMC5883P_Status::OK;
}

void QMC5883P::calibration(bool trigger)
{
    _offset_x = 0;
    _offset_y = 0;
    _offset_z = 0;
    _scale_x = 1;
    _scale_y = 1;
    _scale_z = 1;

    float max[3] = {0};
    float min[3] = {0};
    
    float mag_offset[3] = {0};
    float mag_scale[3] = {0};
    float avg_delta = 0;
    
    while(trigger == true)
    {
        update();
    
        if(getX() >= max[0]) max[0] = getX();
        else if(getX() <= min[0]) min[0] = getX();
        
        if(getY() >= max[1]) max[1] = getY();
        else if(getY() <= min[1]) min[1] = getY();
        
        if(getZ() >= max[2]) max[2] = getZ();
        else if(getZ() <= min[2]) min[2] = getZ();
        
        for(int i = 0; i < 3; i++)
        {
            mag_offset[i] = (max[i] + min[i]) / 2;
            mag_scale[i] = (max[i] - min[i]) / 2;
        }
        avg_delta = (mag_scale[0] + mag_scale[1] + mag_scale[2]) / 3;
        for(int i = 0; i < 3; i++)
        {
            mag_scale[i] = avg_delta / mag_scale[i];
        }
    }    
    
    _offset_x = mag_offset[0];
    _offset_y = mag_offset[1];
    _offset_z = mag_offset[2];
    _scale_x = mag_scale[0];
    _scale_y = mag_scale[1];
    _scale_z = mag_scale[2];
}

void QMC5883P::Delay(uint32_t ms)
{
    R_BSP_SoftwareDelay(ms, BSP_DELAY_UNITS_MILLISECONDS);
}

uint32_t QMC5883P::getTick(void)
{
    // need find out work out
    
    return sysTick;
}



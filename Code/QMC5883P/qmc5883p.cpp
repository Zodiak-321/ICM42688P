/**
 * @file qmc5883p.cpp
 * @brief QMC5883P Magnetometer Sensor Driver Implementation
 * 
 * This file contains the implementation of the QMC5883P class methods
 * for interfacing with the QMC5883P 3-axis magnetometer sensor.
 * 
 * @author WilliTourt willitourt@foxmail.com
 * @version 1.0
 * @date 2025.11.28
 * 
 * @note Comments are mostly generated by AI
 * 
 * @CHANGELOG:
 * - (See qmc5883p.h for changes)
 * 
 */

#include "qmc5883p.h"


/**
 * @brief Construct a new QMC5883P object
 * 
 * @param hi2c Pointer to I2C handle
 * @param mode Operation mode
 * @param speed Output data rate
 * @param range Measurement range
 */
QMC5883P::QMC5883P(I2C_HandleTypeDef* hi2c, QMC5883P_Mode mode, QMC5883P_Spd speed, QMC5883P_Rng range) :
    _hi2c(hi2c),
    _mode(mode),
    _speed(speed),
    _range(range),
    _mag_x(0.0f),
    _mag_y(0.0f),
    _mag_z(0.0f) {
        
    switch (_range) {
        case QMC5883P_Rng::RNG_2G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_2G;
            break;
        case QMC5883P_Rng::RNG_8G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_8G;
            break;
        case QMC5883P_Rng::RNG_12G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_12G;
            break;
        case QMC5883P_Rng::RNG_30G:
            _sensitivity = QMC5883_RNG_SENSITIVITY_30G;
            break;
    }
    
    _offset_x = MAG_X_OFFSET;
    _offset_y = MAG_Y_OFFSET;
    _offset_z = MAG_Z_OFFSET;
    _scale_x = MAG_X_SCALE;
    _scale_y = MAG_Y_SCALE;
    _scale_z = MAG_Z_SCALE;
}

/**
 * @brief Destroy the QMC5883P object
 */
QMC5883P::~QMC5883P() {}

/**
 * @brief Send data to the sensor via I2C
 * 
 * @param reg Register address
 * @param data Pointer to data buffer
 * @param len Length of data
 * @return HAL_StatusTypeDef Status of I2C operation
 */
bool QMC5883P::_i2cSend(uint8_t reg, uint8_t *data, uint8_t len) {
    return HAL_I2C_Mem_Write(_hi2c, QMC5883P_ADDR << 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, QMC5883P_READ_TIMEOUT_MS);
}

/**
 * @brief Receive data from the sensor via I2C
 * 
 * @param reg Register address
 * @param data Pointer to data buffer
 * @param len Length of data
 * @return HAL_StatusTypeDef Status of I2C operation
 */
bool QMC5883P::_i2cRecv(uint8_t reg, uint8_t *data, uint8_t len) {
    return HAL_I2C_Mem_Read(_hi2c, QMC5883P_ADDR << 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, QMC5883P_READ_TIMEOUT_MS);
}

void QMC5883P::Delay(uint32_t ms)
{
    HAL_Delay(ms);
}

uint32_t QMC5883P::getTick(void)
{ 
    return HAL_GetTick();
}

/**
 * @brief Check if new data is available
 * 
 * @return true Data is ready
 * @return false Data is not ready
 */
bool QMC5883P::_isDataRdy() {
    uint8_t isReady = 0;

    if (_i2cRecv(QMC5883P_REG_STATUS, &isReady, 1) != true) {
        return false;
    }
    return (isReady & QMC5883P_STATUS_DRDY);
}

/**
 * @brief Initialize the QMC5883P sensor
 * 
 * This function performs the following steps:
 * 1. Resets the sensor
 * 2. Verifies the chip ID
 * 3. Configures the measurement range
 * 4. Sets the operation mode and data rate
 * 
 * @return QMC5883P_Status Status of initialization
 */
QMC5883P::QMC5883P_Status QMC5883P::begin() {
    uint8_t data;

    Delay(20);
    // Reset the sensor
    data = QMC5883P_CONTROL_2_SOFT_RESET;
    if (_i2cSend(QMC5883P_REG_CONTROL_2, &data, 1) != true) {
        return QMC5883P_Status::ERROR;
    }

    Delay(20);

    data = 0x00;
    if (_i2cSend(QMC5883P_REG_CONTROL_2, &data, 1) != true) {
        return QMC5883P_Status::ERROR;
    }

    Delay(20);

    if (_i2cRecv(QMC5883P_REG_CHIP_ID, &data, 1) != true) {
        return QMC5883P_Status::ERROR;        
    }
    if (data != QMC5883P_CHIP_ID) {
        return QMC5883P_Status::ERROR_ID;        
    }

    data = static_cast<uint8_t>(_range);
    if (_i2cSend(QMC5883P_REG_CONTROL_2, &data, 1) != true) {
        return QMC5883P_Status::ERROR;
    }

    // Configure the sensor
    data = static_cast<uint8_t>(_mode) | static_cast<uint8_t>(_speed) |
           QMC5883P_CONTROL_1_OSR1_2 | QMC5883P_CONTROL_1_OSR2_2;
    if (_i2cSend(QMC5883P_REG_CONTROL_1, &data, 1) != true) {
        return QMC5883P_Status::ERROR;        
    }

    return QMC5883P_Status::OK;
}

/**
 * @brief Read new data from the sensor
 * 
 * This function waits for data to be ready, reads the raw magnetic
 * field data from the sensor, applies calibration offsets and scaling,
 * and stores the calibrated values.
 * 
 * @return QMC5883P_Status Status of data reading
 */
QMC5883P::QMC5883P_Status QMC5883P::update() {
    uint8_t rawData[6];

    uint32_t start = getTick();

    while (!_isDataRdy()) {
        if (getTick() - start > QMC5883P_READ_TIMEOUT_MS) {
            return QMC5883P_Status::ERROR;
        }
        Delay(1);
    }

    if (_i2cRecv(QMC5883P_REG_XOUT_L, rawData, 6) != true) {
        return QMC5883P_Status::ERROR;
    }

    int16_t raw_x = (int16_t)(rawData[1] << 8 | rawData[0]);
    int16_t raw_y = (int16_t)(rawData[3] << 8 | rawData[2]);
    int16_t raw_z = (int16_t)(rawData[5] << 8 | rawData[4]);

    // Apply calibration offsets and scaling
    _mag_x = ((float)raw_x / (float)_sensitivity - _offset_x) * _scale_x;
    _mag_y = ((float)raw_y / (float)_sensitivity - _offset_y) * _scale_y;
    _mag_z = ((float)raw_z / (float)_sensitivity - _offset_z) * _scale_z;

    return QMC5883P_Status::OK;
}

void QMC5883P::calibration(bool trigger)
{
    _offset_x = 0;
    _offset_y = 0;
    _offset_z = 0;
    _scale_x = 1;
    _scale_y = 1;
    _scale_z = 1;

    float max[3] = {0};
    float min[3] = {0};
    
    float mag_offset[3] = {0};
    float mag_scale[3] = {0};
    float avg_delta = 0;
    
    while(trigger == true)
    {
        update();
    
        if(getX() >= max[0]) max[0] = getX();
        else if(getX() <= min[0]) min[0] = getX();
        
        if(getY() >= max[1]) max[1] = getY();
        else if(getY() <= min[1]) min[1] = getY();
        
        if(getZ() >= max[2]) max[2] = getZ();
        else if(getZ() <= min[2]) min[2] = getZ();
        
        for(int i = 0; i < 3; i++)
        {
            mag_offset[i] = (max[i] + min[i]) / 2;
            mag_scale[i] = (max[i] - min[i]) / 2;
        }
        avg_delta = (mag_scale[0] + mag_scale[1] + mag_scale[2]) / 3;
        for(int i = 0; i < 3; i++)
        {
            mag_scale[i] = avg_delta / mag_scale[i];
        }
    }    
    
    _offset_x = mag_offset[0];
    _offset_y = mag_offset[1];
    _offset_z = mag_offset[2];
    _scale_x = mag_scale[0];
    _scale_y = mag_scale[1];
    _scale_z = mag_scale[2];
}




